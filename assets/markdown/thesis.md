<div align="center">
  <img src="assets/images/thesis@2x.png" />
</div>

---

<h5 align="center">Thesis</h5>

<h3 align="center">Meaningful Interaction in Narrative-driven Games</h3>

<h6 align="center">Januari 6th, 2020 - August 27th, 2020</h6>

---

<h4 align="center" id="introduction">Introduction</h4>

---

The way stories are told within narrative-driven games is inherently flawed. The past few years the industry has seen a surge of so-called "cinematic games" which primarily focus on telling a story using techniques commonly found in cinema. We ([Danilo van den Beemt](linkedin.com/in/danilovandenbeemt) and David Wolters) believe that games have the ability to tell stories in a way no other medium can; by means of interaction.

Whilst Danilo focused on the research concerning the nature of interaction, I focused on applying both his and my own research in the shape of a game. A Dutch version of Danilo's research can be found on our website, [ludumstercore.com](https://ludumstercore.com/).

---

<h4 align="center" id="context">Context</h4>

---

> "Interaction is a kind of action that occurs as two or more objects have an effect upon one other." - [Interaction - Wikipedia](https://en.wikipedia.org/wiki/Interaction)

Within the context of our thesis, the objects described are the user (the person playing the game) and a computer. Computers have the unique ability to receive, process and respond to information from the user. The fidelity and speed of the interaction is what we define as the quality of interaction.

Game designer [Chris Crawford](https://en.wikipedia.org/wiki/Chris_Crawford_(game_designer) defines interaction as follows:

> "A cyclic process between two or more active agents in which each agent alternately listens, thinks and speaksâ€”a conversation of sorts."

Listening, speaking and thinking are metaphors. A computer (generally) isn't capable of listening, speaking nor thinking in the way humans do. A computer "listens" to user input, "thinks" by using predefined algorithms and "speaks" by using its peripherals, such as the screen or speakers.

A conversation where one party doesn't listen, speak or thinks isn't a conversation. The general quality of the interaction between the two agents depends on the fidelity (and quality) of every individual step. What exactly the threshold is for a quality conversation is something that Danilo covers in his research, which can be found on our website, [ludumstercore.com](https://ludumstercore.com/).

---

<h4 align="center" id="game">Game</h4>

---

<img src="assets/images/thesis-gameplay.png" alt="ITFE gameplay footage" />

To prove that our research was applicable in practice, I developed game that applied the insights obtained during our research. The game, called ITFE, is playable in both [the browser](https://ludumstercore.com/game) and [free to download for Windows](https://drive.google.com/file/d/1VA29y7w1NmeKmoxb537ruFurPIEId4ZO/view).

The game was made in [TIC-80](https://tic80.com/) and written in JavaScript.

---

<h4 align="center" id="goal">Goal</h4>

---

ITFE is a top-down turn-based tactical RPG, comparable to [Into the Breach](https://subsetgames.com/itb.html) or chess. The player uses a collection of characters to defeat the computer.

To make sure the theory was applied correctly, the following criteria were created:

 - The game does not feature a pre-written story. The story gets generated by means of user interaction.
 - The game uses a collection of predefined personalities that interact with each other and the player to generate scenarios. For example, a character might walk away because they're fearful.
 - The game uses a relationship system. Characters within the game can form relationships which influence the actions they will take. For example, a character might act differently when their partner dies.
 - It's possible to undo actions, which is contextualized in the game. Undoing actions can have various consequences and characters will react differently to them.

These criteria make sure the game being created fits the goal of our thesis; creating a story by means of interaction.

---

<h4 align="center" id="issues">Issues</h4>

---

 - <b>Tight coupling with game mechanics</b>

Creating a high-quality interactive story is complicated. As described before, interaction depends on three key factors: <b>listening</b>, <b>speaking</b> and <b>thinking</b>. These three factors are tightly coupled to the game mechanics, meaning that the overall quality of the story is dependent on the overall quality of the game itself. This makes sense, of course. A game that's not fun to play will most likely not tell a good _interactive_ story either.

 - <b>Lack of narrative context</b>

As per criteria, ITFE does not feature a pre-written story. The theory states, after all, that interactivity on itself should be more than capable of creating an interesting story. However, in practice, that level of interactive quality is very hard to obtain, meaning events within the game don't really make sense without context.

---

<h4 align="center" id="conclusion">Conclusion</h4>

---

Interactive storytelling is very complex. It's something that's very time consuming and hard to get right. For a game to feature a good interactive story it needs high-quality game mechanics that can be used by a procedural story system to create an interactive story.

---

<h4 align="center" id="reflection">Reflection</h4>

---

<h5 id="ai">The difficulty of writing convincing AI</h5>

<img src="/assets/images/thesis-ai.png" alt="ITFE pathfinding AI prototype">

In theory it sounds simple. You take the board state, calculate the best move and perform said move. In practice, however, calculating the best move is incredibly difficult. Something that's quite natural for players to do is very hard to define in a programming language, I've found.

For example, take pathfinding. A player roughly knows that it is advantageous to move your units closer to the enemy so you can attack them. For the AI, this process is far more involved. The AI algorithm looks roughly something like this:

 - Collect all "valuable" tiles on the board (tiles containing buildings or player characters).
 - For each tile, calculate the shortest path using the [A* search algorithm](https://en.wikipedia.org/wiki/A*_search_algorithm).
 - Of all found paths, select the shortest path.
 - If this path is within range of attack, attack this tile.
 - If not, check if the tile is within movement range.
 - If not, select the next shortest path.
 - Else move as close as possible to the destination tile.
 - Again, check if destination is within range of attack and if so, attack the tile.

Of course, this AI algorithm is very rudimentary; it does not care for it's own characters or the board state. Because of the simplicity of the AI, it's very difficult to create an interactive story.

<h5 id="debug">The importance of debugging</h5>

<img src="https://user-images.githubusercontent.com/27073716/83950526-adbb1300-a82b-11ea-8aac-2f1dd1018078.png" alt="Debugging without stack traces">

<img src="https://user-images.githubusercontent.com/27073716/83952832-0692a780-a83c-11ea-8873-8a5905840234.png" alt="Debugging with stack traces">

According to the [TIC-80 website](https://tic80.com/), TIC-80 is "a fantasy computer for making, playing and sharing tiny games". Originally, I chose this engine to make sure the game wouldn't suffer from feature creep. As the game grew in complexity, however, this would become a burden.

One of the biggest issues of working with TIC-80 was the lack of a good debugger. The combination of a small screen (240 x 136) and the lack of a stack trace made debugging a _very_ difficult and time consuming process. To alleviate this problem, I [implemented](https://github.com/nesbox/TIC-80/issues/1113) a stack trace in TIC-80 and [debugged the engine in PowerShell](https://twitter.com/ChronoDave/status/1288083439657328640).

<h5 id="tool">The importance of tooling</h5>

<img src="https://camo.githubusercontent.com/963b2c030d9b3394688df2890fe048a5f55801bbbe22790edb52c79a64c5262d/68747470733a2f2f692e696d6775722e636f6d2f59706578436d342e706e67" alt="Tic-bundle logo" />

Another problem with TIC-80 is the lack of file bundling. As the game grew bigger in size, it become increasingly more difficult to maintain the code. To solve this problem, I wrote a bundler myself, called [tic-bundle](https://github.com/chronoDave/tic-bundle).

<i>Last updated April 21, 2021</i>
